"""Environment setup module - credential collection and .env file generation."""

import os
import re
from pathlib import Path
from typing import Dict, Optional, Tuple
from dotenv import load_dotenv


def check_env_exists(env_path: Optional[Path] = None) -> bool:
    """Check if .env file exists with required credentials."""
    if env_path is None:
        env_path = find_env_file()

    if not env_path or not env_path.exists():
        return False

    load_dotenv(env_path)
    return bool(os.getenv("BACKLOG_SPACE_URL") and os.getenv("BACKLOG_API_KEY"))


def find_env_file() -> Optional[Path]:
    """Find .env file in current or parent directories."""
    current = Path.cwd()

    # Check current directory first
    if (current / ".env").exists():
        return current / ".env"

    # Check parent directories up to 3 levels
    for _ in range(3):
        current = current.parent
        if (current / ".env").exists():
            return current / ".env"

    return None


def collect_credentials(skip_optional: bool = False) -> Dict[str, str]:
    """Collect credentials from user interactively.

    Returns dict with:
    - BACKLOG_SPACE_URL
    - BACKLOG_API_KEY
    - BACKLOG_PROJECT_KEY (optional)
    - GOOGLE_API_KEY (optional, for semantic search)
    """
    print("\n[Step 0] Credentials Setup")
    print("-" * 40)

    credentials = {}

    # Backlog URL
    print("\nBacklog Configuration (required)")
    print("Get API key at: https://your-space.backlog.jp/EditApiSettings.action")

    while True:
        url = input("Backlog Space URL (e.g., your-space.backlog.jp): ").strip()
        if validate_backlog_url(url):
            credentials["BACKLOG_SPACE_URL"] = normalize_backlog_url(url)
            break
        print("  Invalid URL. Enter domain like: your-space.backlog.jp")

    # Backlog API Key
    while True:
        api_key = input("Backlog API Key: ").strip()
        if api_key and len(api_key) >= 20:
            credentials["BACKLOG_API_KEY"] = api_key
            break
        print("  API key required (min 20 characters)")

    # Project key (optional, will be asked in wizard too)
    project_key = input("Default Project Key (optional, e.g., PROJ): ").strip().upper()
    if project_key:
        credentials["BACKLOG_PROJECT_KEY"] = project_key

    # Google API key (optional)
    if not skip_optional:
        print("\nGoogle Gemini API (optional, for semantic search in bk-recall)")
        print("Get key at: https://makersuite.google.com/app/apikey")
        google_key = input("Google API Key (Enter to skip): ").strip()
        if google_key:
            credentials["GOOGLE_API_KEY"] = google_key

    return credentials


def validate_backlog_url(url: str) -> bool:
    """Validate Backlog URL format."""
    if not url:
        return False

    # Remove protocol if present
    url = url.replace("https://", "").replace("http://", "")

    # Check if it looks like a Backlog domain
    patterns = [
        r'^[\w-]+\.backlog\.jp$',      # Japanese Backlog
        r'^[\w-]+\.backlog\.com$',     # US Backlog
        r'^[\w-]+\.backlogtool\.com$', # Legacy
    ]

    return any(re.match(pattern, url) for pattern in patterns)


def normalize_backlog_url(url: str) -> str:
    """Normalize Backlog URL to https://xxx.backlog.jp format."""
    url = url.strip()

    # Remove trailing slash
    url = url.rstrip("/")

    # Remove protocol if present
    url = url.replace("https://", "").replace("http://", "")

    # Add https protocol
    return f"https://{url}"


def generate_env_content(credentials: Dict[str, str], include_comments: bool = True) -> str:
    """Generate .env file content from credentials dict."""
    lines = []

    if include_comments:
        lines.append("# BrseKit Environment Configuration")
        lines.append("# Generated by bk-init")
        lines.append("")
        lines.append("# Backlog API (required)")

    lines.append(f'BACKLOG_SPACE_URL={credentials.get("BACKLOG_SPACE_URL", "")}')
    lines.append(f'BACKLOG_API_KEY={credentials.get("BACKLOG_API_KEY", "")}')

    if credentials.get("BACKLOG_PROJECT_KEY"):
        lines.append(f'BACKLOG_PROJECT_KEY={credentials["BACKLOG_PROJECT_KEY"]}')

    if include_comments:
        lines.append("")
        lines.append("# Google Gemini API (optional, for semantic search)")

    if credentials.get("GOOGLE_API_KEY"):
        lines.append(f'GOOGLE_API_KEY={credentials["GOOGLE_API_KEY"]}')
    else:
        lines.append("# GOOGLE_API_KEY=your-gemini-api-key")

    lines.append("")
    return "\n".join(lines)


def save_env_file(credentials: Dict[str, str], output_dir: Optional[Path] = None) -> Path:
    """Save credentials to .env file.

    Args:
        credentials: Dict of environment variables
        output_dir: Directory to save .env (default: current working directory)

    Returns:
        Path to saved .env file
    """
    if output_dir is None:
        output_dir = Path.cwd()

    env_path = output_dir / ".env"

    # Backup existing .env if it exists
    if env_path.exists():
        backup_path = output_dir / ".env.backup"
        env_path.rename(backup_path)
        print(f"  Existing .env backed up to: {backup_path}")

    content = generate_env_content(credentials)
    env_path.write_text(content, encoding="utf-8")

    return env_path


def test_backlog_connection(space_url: str, api_key: str) -> Tuple[bool, str]:
    """Test Backlog API connection.

    Returns:
        Tuple of (success, message)
    """
    try:
        import urllib.request
        import json

        # Test endpoint - get space info
        url = f"{space_url}/api/v2/space?apiKey={api_key}"

        req = urllib.request.Request(url)
        req.add_header("User-Agent", "BrseKit/1.0")

        with urllib.request.urlopen(req, timeout=10) as response:
            data = json.loads(response.read().decode())
            space_name = data.get("name", "Unknown")
            return True, f"Connected to: {space_name}"

    except urllib.error.HTTPError as e:
        if e.code == 401:
            return False, "Invalid API key"
        return False, f"HTTP error: {e.code}"
    except urllib.error.URLError as e:
        return False, f"Connection failed: {e.reason}"
    except Exception as e:
        return False, f"Error: {str(e)}"


def run_env_setup(output_dir: Optional[Path] = None, force: bool = False) -> Tuple[bool, Dict[str, str]]:
    """Run complete environment setup flow.

    Args:
        output_dir: Directory for .env file
        force: Force reconfigure even if .env exists

    Returns:
        Tuple of (success, credentials_dict)
    """
    if output_dir is None:
        output_dir = Path.cwd()

    env_path = output_dir / ".env"

    # Check existing .env
    if not force and check_env_exists(env_path):
        print("\n.env exists with Backlog credentials.")
        load_dotenv(env_path)

        # Offer to test connection
        space_url = os.getenv("BACKLOG_SPACE_URL")
        api_key = os.getenv("BACKLOG_API_KEY")

        print(f"  Space URL: {space_url}")
        print(f"  API Key: {api_key[:10]}...")

        choice = input("\nTest connection? (y/N): ").strip().lower()
        if choice == "y":
            success, message = test_backlog_connection(space_url, api_key)
            status = "OK" if success else "FAILED"
            print(f"  Connection: {status} - {message}")

        return True, {
            "BACKLOG_SPACE_URL": space_url,
            "BACKLOG_API_KEY": api_key,
            "GOOGLE_API_KEY": os.getenv("GOOGLE_API_KEY", ""),
        }

    # Collect credentials
    credentials = collect_credentials()

    # Test connection
    print("\nTesting Backlog connection...")
    success, message = test_backlog_connection(
        credentials["BACKLOG_SPACE_URL"],
        credentials["BACKLOG_API_KEY"]
    )

    if success:
        print(f"  Connected! {message}")
    else:
        print(f"  Connection failed: {message}")
        retry = input("Continue anyway? (y/N): ").strip().lower()
        if retry != "y":
            return False, {}

    # Save .env
    saved_path = save_env_file(credentials, output_dir)
    print(f"\n Credentials saved to: {saved_path}")

    return True, credentials
